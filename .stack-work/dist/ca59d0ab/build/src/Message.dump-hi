
==================== FINAL INTERFACE ====================
2017-12-03 16:55:27.2939177 UTC

interface FileServerV2-0.1.0.0-4Ug4buDbmyn7TJXR6FeHHh:Message 8002
  interface hash: 5e5a7016b7b8fcfc57d5d98e42383e9a
  ABI hash: 85c9ad2b01fe02b73f0477f6ea00f77e
  export-list hash: bb9a1f860445be53ce208cca7b38c309
  orphan hash: 693e9af84d3dfcc71e640e005bdc5e2e
  flag hash: f8b847b675a91348479da0c1f8d4b9ba
  sig of: Nothing
  used TH splices: False
  where
exports:
  Message.deleteF
  Message.existsF
  Message.finish
  Message.hello
  Message.readF
  Message.stateF
  Message.writeF
  Message.Message
module dependencies:
package dependencies: base-4.9.1.0* ghc-prim-0.5.0.0
                      integer-gmp-1.0.0.1
orphans: base-4.9.1.0:GHC.Base base-4.9.1.0:GHC.Float
family instance modules: base-4.9.1.0:Control.Applicative
                         base-4.9.1.0:Data.Either base-4.9.1.0:Data.Functor.Const
                         base-4.9.1.0:Data.Monoid base-4.9.1.0:Data.Type.Equality
                         base-4.9.1.0:GHC.Generics base-4.9.1.0:GHC.IO.Exception
                         base-4.9.1.0:GHC.TypeLits
import  -/  base-4.9.1.0:GHC.Base 4caea1123ecf4b46e27cbccd6d279377
import  -/  base-4.9.1.0:GHC.IO 4d461f9283683225c61e68db403481ad
import  -/  base-4.9.1.0:GHC.Read 823163de9fa29f31f251382abc171b2b
import  -/  base-4.9.1.0:GHC.Show eca5834daba3b6a2bbbe64ab52056707
import  -/  base-4.9.1.0:Prelude 74b3e204395920329f6de9d97206abe9
import  -/  base-4.9.1.0:Text.ParserCombinators.ReadPrec 5cc8ec62ab8aeda628247695b64f5e42
import  -/  base-4.9.1.0:Text.Read 3cc85705eeac93ec93da7f5edfd7bc15
import  -/  base-4.9.1.0:Text.Read.Lex a861691fe58d2d0a125f55a5ebadf631
import  -/  ghc-prim-0.5.0.0:GHC.Classes 16d48e012d23eaef9bca91ccdd572c02
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage :: GHC.Read.Read Message.Message
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Message.Message
                  Message.$fReadMessage_$creadsPrec
                  Message.$fReadMessage_$creadList
                  Message.$fReadMessage_$creadPrec
                  Message.$fReadMessage_$creadListPrec -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage1 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       ([Message.Message] -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (2, True, False)
                (\ (eta :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta1 :: [Message.Message] -> Text.ParserCombinators.ReadP.P b) ->
                 GHC.Read.list1
                   @ Message.Message
                   Message.$fReadMessage2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Message.Message>_R))
                   eta
                   @ b
                   eta1) -}
0ce57fc7c19b437129aeabf9bdae1224
  $fReadMessage10 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Delete"#) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage11 ::
    (Message.Message -> Text.ParserCombinators.ReadP.P b1)
    -> Text.ParserCombinators.ReadP.P b1
  {- Arity: 1,
     Unfolding: (\ @ b1
                   (k1 :: Message.Message -> Text.ParserCombinators.ReadP.P b1) ->
                 let {
                   lvl81 :: Text.ParserCombinators.ReadP.P b1
                   = let {
                       lvl82 :: Text.ParserCombinators.ReadP.P b1
                       = GHC.Read.$fReadChar2
                           Message.$fReadMessage6
                           @ b1
                           (\ (a1 :: GHC.IO.FilePath) -> k1 (Message.Write a1))
                     } in
                     Text.Read.Lex.expect2
                       @ b1
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString a2 Message.$fReadMessage12 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b1
                               GHC.Types.True -> lvl82 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b1
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl81) -}
                   = \ (w4 :: ()) -> lvl81
                 } in
                 Text.ParserCombinators.ReadP.Look
                   @ b1
                   (\ (a :: GHC.Base.String) ->
                    (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                      @ b1
                      k)) -}
fc66f802d906ac2d02a5a660843d0d4b
  $fReadMessage12 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Write"#) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage13 ::
    (Message.Message -> Text.ParserCombinators.ReadP.P b1)
    -> Text.ParserCombinators.ReadP.P b1
  {- Arity: 1,
     Unfolding: (\ @ b1
                   (k1 :: Message.Message -> Text.ParserCombinators.ReadP.P b1) ->
                 let {
                   lvl81 :: Text.ParserCombinators.ReadP.P b1
                   = let {
                       lvl82 :: Text.ParserCombinators.ReadP.P b1
                       = GHC.Read.$fReadChar2
                           Message.$fReadMessage6
                           @ b1
                           (\ (a1 :: GHC.IO.FilePath) -> k1 (Message.Read a1))
                     } in
                     Text.Read.Lex.expect2
                       @ b1
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString a2 Message.$fReadMessage14 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b1
                               GHC.Types.True -> lvl82 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b1
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl81) -}
                   = \ (w4 :: ()) -> lvl81
                 } in
                 Text.ParserCombinators.ReadP.Look
                   @ b1
                   (\ (a :: GHC.Base.String) ->
                    (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                      @ b1
                      k)) -}
277d09334c44e20893ae1bbc2f29419f
  $fReadMessage14 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Read"#) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage15 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Message.Message)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Message.Message)
                   Message.$fReadMessage20
                   Message.$fReadMessage16) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage16 ::
    [(GHC.Base.String,
      Text.ParserCombinators.ReadPrec.ReadPrec Message.Message)]
  {- Strictness: m2,
     Unfolding: (GHC.Types.:
                   @ (GHC.Base.String,
                      Text.ParserCombinators.ReadPrec.ReadPrec Message.Message)
                   Message.$fReadMessage17
                   (GHC.Types.[]
                      @ (GHC.Base.String,
                         Text.ParserCombinators.ReadPrec.ReadPrec Message.Message))) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage17 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Message.Message)
  {- Strictness: m,
     Unfolding: ((Message.$fReadMessage19,
                  Message.$fReadMessage18
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Message.Message>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Message.Message>_R))))) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage18 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Message.Message -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Message.Message -> Text.ParserCombinators.ReadP.P b) ->
                 eta Message.Finish) -}
156796fe8022e500fd82b080eeef538e
  $fReadMessage19 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Finish"#) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage2 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Message.Message
  {- Arity: 1,
     Unfolding: (GHC.Read.parens1
                   @ Message.Message
                   Message.$fReadMessage3
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Message.Message>_R))) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage20 ::
    ([GHC.Types.Char],
     Text.ParserCombinators.ReadPrec.ReadPrec Message.Message)
  {- Strictness: m,
     Unfolding: ((Message.$fReadMessage22,
                  Message.$fReadMessage21
                    `cast`
                  (Trans
                       (<Text.ParserCombinators.ReadPrec.Prec>_R
                        ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                      <Message.Message>_R))
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Message.Message>_R))))) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage21 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> forall b.
       (Message.Message -> Text.ParserCombinators.ReadP.P b)
       -> Text.ParserCombinators.ReadP.P b
  {- Arity: 2, HasNoCafRefs, Strictness: <L,A><C(S),1*C1(U)>,
     Unfolding: InlineRule (2, True, True)
                (\ (ds :: Text.ParserCombinators.ReadPrec.Prec)
                   @ b
                   (eta :: Message.Message -> Text.ParserCombinators.ReadP.P b) ->
                 eta Message.Hello) -}
31ac4cb78ec32628649d6c613064fe05
  $fReadMessage22 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Hello"#) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage23 :: Text.ParserCombinators.ReadP.P [Message.Message]
  {- Unfolding: (GHC.Read.list1
                   @ Message.Message
                   Message.$fReadMessage2
                     `cast`
                   (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                             <Message.Message>_R))
                   GHC.Read.$fRead()5
                   @ [Message.Message]
                   (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                      @ [Message.Message])) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage3 ::
    Text.ParserCombinators.ReadPrec.Prec
    -> Text.ParserCombinators.ReadP.ReadP Message.Message
  {- Arity: 1, Strictness: <L,U(U)>,
     Unfolding: (\ (n :: Text.ParserCombinators.ReadPrec.Prec) ->
                 let {
                   ds2 :: Text.ParserCombinators.ReadP.ReadP Message.Message
                   = GHC.Read.choose2 @ Message.Message Message.$fReadMessage15 n
                 } in
                 let {
                   ds1 :: Text.ParserCombinators.ReadP.ReadP Message.Message
                   = case n of wild { GHC.Types.I# x ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 10#) of wild2 {
                       GHC.Types.False
                       -> (Text.ParserCombinators.ReadP.pfail1 @ Message.Message)
                            `cast`
                          (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R))
                       GHC.Types.True
                       -> Message.$fReadMessage13
                            `cast`
                          (Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <Message.Message>_R)) } }
                 } in
                 let {
                   ds3 :: Text.ParserCombinators.ReadP.ReadP Message.Message
                   = case n of wild { GHC.Types.I# x ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 10#) of wild2 {
                       GHC.Types.False
                       -> (Text.ParserCombinators.ReadP.pfail1 @ Message.Message)
                            `cast`
                          (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R))
                       GHC.Types.True
                       -> Message.$fReadMessage11
                            `cast`
                          (Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <Message.Message>_R)) } }
                 } in
                 let {
                   ds4 :: Text.ParserCombinators.ReadP.ReadP Message.Message
                   = case n of wild { GHC.Types.I# x ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 10#) of wild2 {
                       GHC.Types.False
                       -> (Text.ParserCombinators.ReadP.pfail1 @ Message.Message)
                            `cast`
                          (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R))
                       GHC.Types.True
                       -> Message.$fReadMessage9
                            `cast`
                          (Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <Message.Message>_R)) } }
                 } in
                 let {
                   ds5 :: Text.ParserCombinators.ReadP.ReadP Message.Message
                   = case n of wild { GHC.Types.I# x ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 10#) of wild2 {
                       GHC.Types.False
                       -> (Text.ParserCombinators.ReadP.pfail1 @ Message.Message)
                            `cast`
                          (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R))
                       GHC.Types.True
                       -> Message.$fReadMessage7
                            `cast`
                          (Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <Message.Message>_R)) } }
                 } in
                 let {
                   ds6 :: Text.ParserCombinators.ReadP.ReadP Message.Message
                   = case n of wild { GHC.Types.I# x ->
                     case GHC.Prim.tagToEnum#
                            @ GHC.Types.Bool
                            (GHC.Prim.<=# x 10#) of wild2 {
                       GHC.Types.False
                       -> (Text.ParserCombinators.ReadP.pfail1 @ Message.Message)
                            `cast`
                          (Sym (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R))
                       GHC.Types.True
                       -> Message.$fReadMessage4
                            `cast`
                          (Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <Message.Message>_R)) } }
                 } in
                 (\ @ b
                    (k :: Message.Message -> Text.ParserCombinators.ReadP.P b) ->
                  Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                    @ b
                    (ds2
                       `cast`
                     (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R)
                       @ b
                       k)
                    (Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                       @ b
                       (ds1
                          `cast`
                        (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R)
                          @ b
                          k)
                       (Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                          @ b
                          (ds3
                             `cast`
                           (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R)
                             @ b
                             k)
                          (Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                             @ b
                             (ds4
                                `cast`
                              (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R)
                                @ b
                                k)
                             (Text.ParserCombinators.ReadP.$fAlternativeP_$c<|>
                                @ b
                                (ds5
                                   `cast`
                                 (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R)
                                   @ b
                                   k)
                                (ds6
                                   `cast`
                                 (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R)
                                   @ b
                                   k))))))
                   `cast`
                 (Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                           <Message.Message>_R))) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage4 ::
    (Message.Message -> Text.ParserCombinators.ReadP.P b1)
    -> Text.ParserCombinators.ReadP.P b1
  {- Arity: 1,
     Unfolding: (\ @ b1
                   (k1 :: Message.Message -> Text.ParserCombinators.ReadP.P b1) ->
                 let {
                   lvl81 :: Text.ParserCombinators.ReadP.P b1
                   = let {
                       lvl82 :: Text.ParserCombinators.ReadP.P b1
                       = GHC.Read.$fReadChar2
                           Message.$fReadMessage6
                           @ b1
                           (\ (a1 :: GHC.IO.FilePath) -> k1 (Message.State a1))
                     } in
                     Text.Read.Lex.expect2
                       @ b1
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString a2 Message.$fReadMessage5 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b1
                               GHC.Types.True -> lvl82 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b1
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl81) -}
                   = \ (w4 :: ()) -> lvl81
                 } in
                 Text.ParserCombinators.ReadP.Look
                   @ b1
                   (\ (a :: GHC.Base.String) ->
                    (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                      @ b1
                      k)) -}
9df625ad7b03b6887ad21913ff81d633
  $fReadMessage5 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "State"#) -}
5f76a5a7a157276f94546df2232b57d9
  $fReadMessage6 :: GHC.Types.Int
  {- HasNoCafRefs, Unfolding: (GHC.Types.I# 11#) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage7 ::
    (Message.Message -> Text.ParserCombinators.ReadP.P b1)
    -> Text.ParserCombinators.ReadP.P b1
  {- Arity: 1,
     Unfolding: (\ @ b1
                   (k1 :: Message.Message -> Text.ParserCombinators.ReadP.P b1) ->
                 let {
                   lvl81 :: Text.ParserCombinators.ReadP.P b1
                   = let {
                       lvl82 :: Text.ParserCombinators.ReadP.P b1
                       = GHC.Read.$fReadChar2
                           Message.$fReadMessage6
                           @ b1
                           (\ (a1 :: GHC.IO.FilePath) -> k1 (Message.Exists a1))
                     } in
                     Text.Read.Lex.expect2
                       @ b1
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString a2 Message.$fReadMessage8 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b1
                               GHC.Types.True -> lvl82 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b1
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl81) -}
                   = \ (w4 :: ()) -> lvl81
                 } in
                 Text.ParserCombinators.ReadP.Look
                   @ b1
                   (\ (a :: GHC.Base.String) ->
                    (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                      @ b1
                      k)) -}
42b5acce61511ea074561073bea5586d
  $fReadMessage8 :: [GHC.Types.Char]
  {- Unfolding: (GHC.CString.unpackCString# "Exists"#) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage9 ::
    (Message.Message -> Text.ParserCombinators.ReadP.P b1)
    -> Text.ParserCombinators.ReadP.P b1
  {- Arity: 1,
     Unfolding: (\ @ b1
                   (k1 :: Message.Message -> Text.ParserCombinators.ReadP.P b1) ->
                 let {
                   lvl81 :: Text.ParserCombinators.ReadP.P b1
                   = let {
                       lvl82 :: Text.ParserCombinators.ReadP.P b1
                       = GHC.Read.$fReadChar2
                           Message.$fReadMessage6
                           @ b1
                           (\ (a1 :: GHC.IO.FilePath) -> k1 (Message.Delete a1))
                     } in
                     Text.Read.Lex.expect2
                       @ b1
                       (\ (a1 :: Text.Read.Lex.Lexeme) ->
                        case a1 of wild {
                          DEFAULT -> Text.ParserCombinators.ReadP.Fail @ b1
                          Text.Read.Lex.Ident a2
                          -> case GHC.Base.eqString a2 Message.$fReadMessage10 of wild1 {
                               GHC.Types.False -> Text.ParserCombinators.ReadP.Fail @ b1
                               GHC.Types.True -> lvl82 } })
                 } in
                 let {
                   k :: () -> Text.ParserCombinators.ReadP.P b1
                     {- Arity: 1, Strictness: <L,A>, Inline: INLINE[0],
                        Unfolding: InlineRule (1, True, True) (\ (w4 :: ()) -> lvl81) -}
                   = \ (w4 :: ()) -> lvl81
                 } in
                 Text.ParserCombinators.ReadP.Look
                   @ b1
                   (\ (a :: GHC.Base.String) ->
                    (Text.ParserCombinators.ReadP.skipSpaces_skip a)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <()>_R)
                      @ b1
                      k)) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage_$creadList ::
    Text.ParserCombinators.ReadP.ReadS [Message.Message]
  {- Arity: 1,
     Unfolding: (Text.ParserCombinators.ReadP.run
                   @ [Message.Message]
                   Message.$fReadMessage23) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage_$creadListPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec [Message.Message]
  {- Arity: 2, Strictness: <L,U><L,U>,
     Unfolding: InlineRule (0, True, True)
                Message.$fReadMessage1
                  `cast`
                (Trans
                     (<Text.ParserCombinators.ReadPrec.Prec>_R
                      ->_R Sym (Text.ParserCombinators.ReadP.N:ReadP[0]
                                    <[Message.Message]>_R))
                     (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                               <[Message.Message]>_R))) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage_$creadPrec ::
    Text.ParserCombinators.ReadPrec.ReadPrec Message.Message
  {- Arity: 1,
     Unfolding: InlineRule (0, True, True)
                Message.$fReadMessage2
                  `cast`
                (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                          <Message.Message>_R)) -}
1f64b8c480bd094baf25df45312ecdaa
  $fReadMessage_$creadsPrec ::
    GHC.Types.Int -> Text.ParserCombinators.ReadP.ReadS Message.Message
  {- Arity: 1, Strictness: <L,U>,
     Unfolding: InlineRule (1, True, False)
                (\ (eta :: GHC.Types.Int) ->
                 Text.ParserCombinators.ReadP.run
                   @ Message.Message
                   ((GHC.Read.parens1
                       @ Message.Message
                       Message.$fReadMessage3
                         `cast`
                       (Sym (Text.ParserCombinators.ReadPrec.N:ReadPrec[0]
                                 <Message.Message>_R))
                       eta)
                      `cast`
                    (Text.ParserCombinators.ReadP.N:ReadP[0] <Message.Message>_R)
                      @ Message.Message
                      (Text.ParserCombinators.ReadP.$fApplicativeP_$cpure
                         @ Message.Message))) -}
1f64b8c480bd094baf25df45312ecdaa
  $fShowMessage :: GHC.Show.Show Message.Message
  DFunId
  {- Strictness: m, Inline: [ALWAYS] CONLIKE,
     Unfolding: DFun:.
                  @ Message.Message
                  Message.$fShowMessage_$cshowsPrec
                  Message.$fShowMessage_$cshow
                  Message.$fShowMessage_$cshowList -}
1f64b8c480bd094baf25df45312ecdaa
  $fShowMessage1 :: Message.Message -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (Message.$fShowMessage_$cshowsPrec
                   Message.$fShowMessage2) -}
50f5ba68e524bd9a16a9bd29688735bc
  $fShowMessage2 :: GHC.Types.Int
  {- HasNoCafRefs, Strictness: m, Unfolding: (GHC.Types.I# 0#) -}
1f64b8c480bd094baf25df45312ecdaa
  $fShowMessage_$cshow :: Message.Message -> GHC.Base.String
  {- Arity: 1, Strictness: <S,1*U>,
     Unfolding: InlineRule (1, True, False)
                (\ (x :: Message.Message) ->
                 Message.$fShowMessage_$cshowsPrec
                   GHC.Show.shows22
                   x
                   (GHC.Types.[] @ GHC.Types.Char)) -}
1f64b8c480bd094baf25df45312ecdaa
  $fShowMessage_$cshowList :: [Message.Message] -> GHC.Show.ShowS
  {- Arity: 2,
     Unfolding: (GHC.Show.showList__
                   @ Message.Message
                   Message.$fShowMessage1) -}
1f64b8c480bd094baf25df45312ecdaa
  $fShowMessage_$cshowsPrec ::
    GHC.Types.Int -> Message.Message -> GHC.Show.ShowS
  {- Arity: 3, Strictness: <L,1*U(U)><S,1*U><L,U> -}
fe562439a92cd9a579687004f527baec
  $tc'Delete :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   10413178166552075974##
                   7280967352259614267##
                   Message.$trModule
                   Message.$tc'Delete1) -}
6f7d76ffdd97e12964a2241f96851a0c
  $tc'Delete1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Delete"#) -}
a8bf059d59edffd97840673c6f3d5b7c
  $tc'Exists :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11136167217416783639##
                   3696011145336455143##
                   Message.$trModule
                   Message.$tc'Exists1) -}
96d5d87ef79933ef15216e4958116fa7
  $tc'Exists1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Exists"#) -}
7cb45ffcffcfcea6329c00cd55f6a472
  $tc'Finish :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   15369976381193448085##
                   9302059722444926396##
                   Message.$trModule
                   Message.$tc'Finish1) -}
a27694cdb1940290b44b52212b987cf9
  $tc'Finish1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Finish"#) -}
2d88db87674105ea0f907fd6835082fe
  $tc'Hello :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   17071022993811650240##
                   1815407806152210621##
                   Message.$trModule
                   Message.$tc'Hello1) -}
d7199edc4fd9b4eb7d11e7c9fa48351f
  $tc'Hello1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Hello"#) -}
29dd04ac11d0a3a44bce0b68b1fde7a1
  $tc'Read :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   9935976223296196611##
                   1050896906923413314##
                   Message.$trModule
                   Message.$tc'Read1) -}
84c46642f1611ce3ea383802349b68ae
  $tc'Read1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Read"#) -}
fd06a976467c8088e3e37cdaf6e7f0fa
  $tc'State :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   11308680167477250063##
                   9817072032972325610##
                   Message.$trModule
                   Message.$tc'State1) -}
b746ff23e5277763d3bd2a05049b3691
  $tc'State1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'State"#) -}
596f377ff3dc35e85e4dc8cf53002c23
  $tc'Write :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   198086947990398524##
                   1997772514049748931##
                   Message.$trModule
                   Message.$tc'Write1) -}
66d93098e750432bdab4e38403d89327
  $tc'Write1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "'Write"#) -}
2290c8158bb0fc7cabb6a9dcfa770498
  $tcMessage :: GHC.Types.TyCon
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.TyCon
                   2667238544310369827##
                   11401142873534773869##
                   Message.$trModule
                   Message.$trModule1) -}
bf3c8605acbb27f15cc4709beeaf7d41
  $trModule :: GHC.Types.Module
  {- HasNoCafRefs, Strictness: m,
     Unfolding: (GHC.Types.Module
                   Message.$trModule2
                   Message.$trModule1) -}
562c5fbb9a2c45bb589bdd4a119d8b84
  $trModule1 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS "Message"#) -}
50c88c933daf8c3527c9332d5deaceb2
  $trModule2 :: GHC.Types.TrName
  {- HasNoCafRefs, Strictness: m1,
     Unfolding: (GHC.Types.TrNameS
                   "FileServerV2-0.1.0.0-4Ug4buDbmyn7TJXR6FeHHh"#) -}
1f64b8c480bd094baf25df45312ecdaa
  data Message
    = Read GHC.IO.FilePath
    | Write GHC.IO.FilePath
    | Delete GHC.IO.FilePath
    | Exists GHC.IO.FilePath
    | State GHC.IO.FilePath
    | Hello
    | Finish
084e9f1839c8c2fe0a1a2099e2e1a117
  deleteF :: GHC.IO.FilePath -> Message.Message
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m3,
     Unfolding: InlineRule (0, True, True) Message.Delete -}
245efcaee6d2a42558fc5756e85f919e
  existsF :: GHC.IO.FilePath -> Message.Message
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m4,
     Unfolding: InlineRule (0, True, True) Message.Exists -}
38cc1a5e0655f08fbc4eaf1b4ae0621f
  finish :: Message.Message
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True) Message.Finish -}
fdcc53adf40d6bcbf28d20aa684e68a6
  hello :: Message.Message
  {- HasNoCafRefs,
     Unfolding: InlineRule (0, True, True) Message.Hello -}
3c32c39fbd2b17e43b3277f681a1aaae
  readF :: GHC.IO.FilePath -> Message.Message
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m1,
     Unfolding: InlineRule (0, True, True) Message.Read -}
2d56781f59c8caaf04f8c8f5a8c94bba
  stateF :: GHC.IO.FilePath -> Message.Message
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m5,
     Unfolding: InlineRule (0, True, True) Message.State -}
b0e8c5160642efdc2ec10d69e11bdd00
  writeF :: GHC.IO.FilePath -> Message.Message
  {- Arity: 1, HasNoCafRefs, Strictness: <L,U>m2,
     Unfolding: InlineRule (0, True, True) Message.Write -}
instance [safe] GHC.Read.Read [Message.Message]
  = Message.$fReadMessage
instance [safe] GHC.Show.Show [Message.Message]
  = Message.$fShowMessage
vectorised variables:
vectorised tycons:
vectorised reused tycons:
parallel variables:
parallel tycons:
trusted: safe
require own pkg trusted: False

